# Двоични числа

## `Bin`
Досега сме работели само с пеанови числа, които са доста неефективни, тъй като
се конструират линейно, съответно и повечето операции с тях имат лоши сложности.

Ще разгледаме друго кодиране на числа, по-близко до това което реално ползват компютрите, а именно като поредица от битове.

```agda
data Bin : Set where
  end : Bin
  _O : Bin -> Bin
  _I : Bin -> Bin
```

С конструктора `_O` ще индикираме че сегашният ни бит "е нула", а с `_I`, че "е единиица".

Конструкторите са дефинирани като постфиксни оператори с цел да съответстват на това как традиционно
пишем двоични числа на лист хартия. Например чрез
```agda
_ : Bin
_ = end I I O
```
ще изразим числото `6`, записано `110` в двоичен запис.

Нека също обърнем внимание нa `import` декларациите ни:
```
import Lib.Nat as Nat
open Nat using (Nat; _+N_)
```

Тъй като ни се иска да преизползваме `suc` със значението "събиране с едно" и за двоичните ни числа,
трябва да квалифицираме `suc`, което идва от `Lib.Nat`, за да няма нееднозначност.

Съответно за да реферираме към функции от `Lib.Nat`, трябва да им сложим префикс `Nat.`, например `Nat.+N-right-suc`.

Единствено оператора `_+N_` и самият тип `Nat` са `import`-нати не-квалифицирано.

## 00. `suc`

Имплементирайте функцията "събиране с едно" над двоични числа.
```agda
suc : Bin -> Bin

_ : suc end == end I
_ = refl

_ : suc (end I I) == end I O O
_ = refl
```

## 01. `toNat`

Имплементирайте конверсия от двоични числа, към пеанови. Препоръчаният начин е да използвате `_+N_`
```agda
toNat : Bin -> Nat

_ : toNat (end I I I) == 7
_ = refl

_ : toNat (end I I O) == 6
_ = refl

_ : toNat (end O) == 0
_ = refl

_ : toNat end == 0
_ = refl
```

## 02. `fromNat`

Имплементирайте конверсия от пеанови числа, към двоични. Изполвайте `suc`.

```agda
fromNat : Nat -> Bin

_ : fromNat 0 == end
_ = refl

_ : fromNat 1 == end I
_ = refl

_ : fromNat 8 == end I O O O
_ = refl
```

## 03. `toNat-suc`

Докажете че "`suc` се държи както `Nat.suc`".
```agda
toNat-suc : (b : Bin) -> toNat (suc b) == Nat.suc (toNat b)
```

## 04. `to-from-id`

Вярно ли е че ако конвертираме от пеаново число към двоично и после обратно, ще получим оригиналното пеаново число?
Ако да, го докажете:
```agda
to-from-id : (n : Nat) -> toNat (fromNat n) == n
```
Ако не, дайте контрапример, т.е. имплементирайте
```agda
to-from-counterexample : Nat >< \n -> toNat (fromNat n) == n -> Zero
```

## 05. `from-to-id`

Вярно ли е че ако конвертираме от двоично към пеаново и после обратно, ще получим оригиналното двоично число?
Ако да, го докажете:
```agda
from-to-id : (b : Bin) -> fromNat (toNat b) == b
```

Ако не, дайте контрапример, т.е. имплементирайте
```agda
from-to-counterexample : Bin >< \b -> fromNat (toNat b) == b -> Zero
```


## Канонични двоични числа
Ами оказва се че както са дефинирани числата ни в момента, `(b : Bin) -> fromNat (toNat b) == b` не е вярно.

Проблемът идва от това, че двоичните ни числа могат да имат произволен брои "водещи" нули.

"Водеща" нула ще наричаме нула, които или е до `end` (например `end O`), или е до друга водеща нула
(напеример дясната `O` в израза `end O O`)

Интуитивно - излишните нули, които можем да пишем колкото искаме от тях на лист хартия най-отляво, но "не правят нищо".

Чисто синтактично `end O I O` и `end I O` не са един и същ обект, но ние се държим с тях сякаш са
(именно `toNat (end O I O) == toNat (end I O)`).

За да коригираме това, ще изобретим два типа, които да "оправят" този проблем,
чрез които да можем после да докажем коригирана версия на `from-to-id`.

### `LeadingOne`
Чрез този тип, ще кодираме свойството "двоично число да е с водеща единица".
```agda
data LeadingOne : Bin -> Set where
  endI : LeadingOne (end I)
  _O : {b : Bin} -> LeadingOne b -> LeadingOne (b O)
  _I : {b : Bin} -> LeadingOne b -> LeadingOne (b I)
```
Конструкторите са почти огледални на самото `Bin`, с разликата че базовият случай, `endI`, се конструира само с двоичното число `end I`.

С други думи, както и да слепяме битове кям `LeadingOne`, "най-отдолу" винаги ще седи една единица.

Това почти ни върши работа, но с тази система нямаме начин да изразим като двоично число нулата.

### `Can`
Съответно "канонично" двоично число, ще наричаме такова, което или е нула, или има водеща единица.
```agda
data Can : Bin -> Set where
  end : Can end
  leadingOne : {b : Bin} -> LeadingOne b -> Can b
```
Хубаво е да отбележим че тук не е задължително да избираме `end` за нула, т.е. можеше да изберем също и `end O` например.

Това което трябва да променим обаче, е че в нашите дефиниции на `toNat` и `fromNat`, също имплицитно сме "избрали" `end`
за нула. Съответно ако решим да "ползваме друга нула" тук, трябва и те евентуално да се модифицират.

Поради естеството на дефиницията на `Can` често ще ни трябва "една и съща" лема два пъти -
един път за `LeadingOne` и един път за `Can`. Първата обикновенно е нужна за да докажем втората

## 06. `suc-LeadingOne`
Докажете че събирането с едно запазва свойството двоично число да започва с единица.
```agda
suc-LeadingOne : (b : Bin) -> LeadingOne b -> LeadingOne (suc b)
```

## 07. `suc-Can`
Докажете че събирането с едно запазва свойството двоично число да е канонично.
```agda
suc-Can : (b : Bin) -> Can b -> Can (suc b)
```

## 08. `fromNat-Can`
Докажете че конверсията ни от естествено число към двоично винаги има за резултат канонично двоично число.
```agda
fromNat-Can : (n : Nat) -> Can (fromNat n)
```

## `from-to-id-Can`
Допускайки свойството "каноничност" за дадено двоично число, вече ще можем да докажем, че
конвертирането към естествено и обратно води до оригиналното число.

Но първо ще ни трябват няколко помощни дефиниции и леми.

#### Забележка 0
Това, че има дадени леми тук, не означава че трябва да се ограничавате да ползвате само тях.

Напротив, някои от по-дребните такива които са удобни и/или нужни, не съм представил тук, с цел сами да ги измислите.

#### Забележка 1
Ако имате и други идеи за доказателство на
```agda
from-to-id-Can : (b : Bin) -> Can b -> fromNat (toNat b) == b
```
можете да пропуснете тези дефиниции и леми и да използвате вашите вместо това.

## 09. `_+B_`

Събиране на двоични числа. Полезно е, тъй като (предполагаме че) дефиницията ни на `toNat` използва
`_+N_`. Проличава си, когато тръгнем да доказваме `from-to-id-Can`.

```agda
_+B_ : Bin -> Bin -> Bin

infixr 11 _+B_

_ : end +B end I I I I == end I I I I
_ = refl

_ : end I O O +B end == end I O O
_ = refl

_ : end I I +B end I I I I == end I O O I O
_ = refl

_ : end I I I +B end I O I == end I I O O
_ = refl
```

## 10. `+B-right-end`

`end` е десен неутрален елемент за `_+B_`.

```agda
+B-right-end : (b : Bin) -> b +B end == b
```

## 11. `+B-left-suc`
Можем да "изкарваме `suc` навън" от лявата страна на `_+B_`.

```agda
+B-left-suc : (b v : Bin) -> suc b +B v == suc (b +B v)
```

## 12. `+B-right-suc`
Можем да "изкарваме `suc` навън" от дясната страна на `_+B_`.

```agda
+B-right-suc : (b v : Bin) -> b +B suc v == suc (b +B v)
```

## 13. `fromNat-+N-+B-commutes`
`fromNat` "комутира" в отношение с `_+N_` и `_+B_`.

```agda
fromNat-+N-+B-commutes : (n m : Nat) -> fromNat (n +N m) == fromNat n +B fromNat m
```

## 14. `+B-same-shift`
Събирането на двоично число, с водеща единица, два пъти със себе си, е същото като да "изместим наляво" (bitwise shift) числото.
```agda
+B-same-shift : (b : Bin) -> LeadingOne b -> b +B b == b O
```

## 15. `from-to-id-Can`

Ако конвертираме от канонично двоично число в пеаново и обратно, получаваме оригиналното двоично число.
```agda
from-to-id-Can : (b : Bin) -> Can b -> fromNat (toNat b) == b
```
